# ==============================================================
# Argus AI - CI/CD Pipeline
# ==============================================================
# Lint e Test rodam em paralelo para feedback rapido.
# Deploy so executa apos ambos passarem, apenas na branch main.
# ==============================================================

name: CI

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]
  workflow_dispatch:

# Permissao minima global - jobs sobrescrevem quando necessario
permissions:
  contents: read

# Cancela runs anteriores da mesma branch/PR
concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

env:
  PYTHON_VERSION: "3.11"
  PIP_DISABLE_PIP_VERSION_CHECK: "1"
  PIP_NO_PYTHON_VERSION_WARNING: "1"

defaults:
  run:
    shell: bash

# ==============================================================
jobs:

  # -- Lint (ruff check + format) ------------------------------
  lint:
    name: Lint
    runs-on: ubuntu-latest
    timeout-minutes: 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python
        uses: ./.github/actions/setup-python-env
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          install-deps: lint

      - name: Ruff lint
        run: ruff check app/ tests/ --output-format=github

      - name: Ruff format check
        run: ruff format --check app/ tests/

  # -- Test (pytest + coverage) -------------------------------
  test:
    name: Test
    runs-on: ubuntu-latest
    timeout-minutes: 15

    services:
      postgres:
        image: postgis/postgis:16-3.4
        env:
          POSTGRES_USER: test
          POSTGRES_PASSWORD: test
          POSTGRES_DB: argus_test
        ports:
          - 5432:5432
        options: >-
          --health-cmd "pg_isready -U test -d argus_test"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python + deps
        uses: ./.github/actions/setup-python-env
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          install-deps: dev

      # -- Database setup -----------------------------------
      - name: Wait for PostgreSQL
        run: |
          for i in $(seq 1 60); do
            if docker exec "${{ job.services.postgres.id }}" pg_isready -U test -d argus_test 2>/dev/null; then
              echo "PostgreSQL pronto"
              exit 0
            fi
            sleep 1
          done
          echo "::error::PostgreSQL nao ficou saudavel em 60s"
          docker logs "${{ job.services.postgres.id }}" 2>&1 | tail -20 || true
          exit 1

      - name: Install pgvector extension
        run: |
          docker exec --user root "${{ job.services.postgres.id }}" bash -euxo pipefail -c '
            if [ -f /usr/share/postgresql/16/extension/vector.control ]; then
              echo "pgvector ja disponivel"
              exit 0
            fi
            apt-get update -qq
            if apt-cache show postgresql-16-pgvector >/dev/null 2>&1; then
              apt-get install -y --no-install-recommends postgresql-16-pgvector
            else
              apt-get install -y --no-install-recommends \
                ca-certificates git build-essential postgresql-server-dev-16
              git clone --branch v0.8.1 --depth 1 https://github.com/pgvector/pgvector.git /tmp/pgvector
              cd /tmp/pgvector && make && make install
            fi
          '

      - name: Create PostgreSQL extensions
        run: |
          EXTENSIONS="pgcrypto postgis vector pg_trgm unaccent"
          for ext in $EXTENSIONS; do
            docker exec -e PGPASSWORD=test "${{ job.services.postgres.id }}" \
              psql -v ON_ERROR_STOP=1 -U test -d argus_test \
              -c "CREATE EXTENSION IF NOT EXISTS $ext;"
            echo "Extension $ext criada"
          done

      # -- S3 (MinIO) --------------------------------------
      - name: Start MinIO
        run: |
          docker run -d -p 9000:9000 --name minio \
            -e MINIO_ROOT_USER=test \
            -e MINIO_ROOT_PASSWORD=test \
            minio/minio:RELEASE.2024-06-13T22-53-53Z server /data

      - name: Wait for MinIO
        run: |
          for i in $(seq 1 30); do
            if curl -fsS http://localhost:9000/minio/health/live >/dev/null 2>&1; then
              echo "MinIO pronto"
              exit 0
            fi
            sleep 1
          done
          echo "::error::MinIO nao ficou saudavel em 30s"
          docker logs minio 2>&1 | tail -20 || true
          exit 1

      # -- Testes -------------------------------------------
      - name: Create S3 test bucket
        env:
          S3_ENDPOINT: http://localhost:9000
          S3_ACCESS_KEY: test
          S3_SECRET_KEY: test
          S3_BUCKET: argus-test
        run: |
          python -c "
          import os, boto3
          s3 = boto3.client('s3',
              endpoint_url=os.environ['S3_ENDPOINT'],
              aws_access_key_id=os.environ['S3_ACCESS_KEY'],
              aws_secret_access_key=os.environ['S3_SECRET_KEY'])
          s3.create_bucket(Bucket=os.environ['S3_BUCKET'])
          print('Bucket criado: ' + os.environ['S3_BUCKET'])
          "

      - name: Run tests
        env:
          DATABASE_URL: postgresql://test:test@localhost:5432/argus_test
          REDIS_URL: redis://localhost:6379
          SECRET_KEY: test-secret-key-ci-32bytes-long!!
          ENCRYPTION_KEY: YLPrjiTU1zUbkNkp4Mwq7XZlj0ysJIDnfUdGnSHULDg=
          S3_ENDPOINT: http://localhost:9000
          S3_ACCESS_KEY: test
          S3_SECRET_KEY: test
          S3_BUCKET: argus-test
        run: |
          pytest \
            --maxfail=5 \
            --disable-warnings \
            -q \
            --cov=app \
            --cov-report=xml \
            --tb=short \
            2>&1 | tee pytest.log
          test ${PIPESTATUS[0]} -eq 0

      # -- Artefatos e debug --------------------------------
      - name: Collect service logs on failure
        if: failure()
        run: |
          {
            echo "=== PostgreSQL logs ==="
            docker logs "${{ job.services.postgres.id }}" 2>&1 | tail -50 || true
            echo ""
            echo "=== Redis logs ==="
            docker logs "${{ job.services.redis.id }}" 2>&1 | tail -50 || true
            echo ""
            echo "=== MinIO logs ==="
            docker logs minio 2>&1 | tail -50 || true
          } > ci-debug.log

      - name: Upload test artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-artifacts
          path: |
            pytest.log
            coverage.xml
            ci-debug.log
          if-no-files-found: ignore
          retention-days: 14

  # -- Deploy (Oracle Cloud) ----------------------------------
  deploy:
    name: Deploy
    runs-on: ubuntu-latest
    needs: [lint, test]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    timeout-minutes: 10

    # Permissoes minimas para deploy
    permissions:
      contents: read
      deployments: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Validate deploy secrets
        id: validate_deploy
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
        run: |
          missing=""
          [ -z "$DEPLOY_HOST" ] && missing="$missing DEPLOY_HOST"
          [ -z "$DEPLOY_USER" ] && missing="$missing DEPLOY_USER"
          [ -z "$DEPLOY_KEY" ] && missing="$missing DEPLOY_KEY"
          if [ -n "$missing" ]; then
            echo "::warning::Secrets de deploy nao configurados:$missing"
            echo "skip_deploy=true" >> "$GITHUB_OUTPUT"
          else
            echo "skip_deploy=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Deploy to production
        if: steps.validate_deploy.outputs.skip_deploy != 'true'
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_KEY: ${{ secrets.DEPLOY_KEY }}
        run: |
          # Configurar SSH com seguranca
          install -m 700 -d ~/.ssh
          echo "$DEPLOY_KEY" | install -m 600 /dev/stdin ~/.ssh/deploy_key
          ssh-keyscan -H "$DEPLOY_HOST" >> ~/.ssh/known_hosts 2>/dev/null

          # Deploy remoto
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=yes \
            "${DEPLOY_USER}@${DEPLOY_HOST}" << 'DEPLOY_SCRIPT'
            set -euo pipefail
            cd ~/argus-ai || exit 1

            echo "Atualizando codigo..."
            git pull origin main

            echo "Rebuild e restart..."
            docker compose -f docker-compose.prod.yml build --pull
            docker compose -f docker-compose.prod.yml up -d

            echo "Executando migrations..."
            docker compose -f docker-compose.prod.yml exec -T api \
              python -m alembic upgrade head || echo "::warning::Migrations falharam"

            echo "Verificando saude..."
            sleep 5
            curl -fsS http://localhost:8000/health || echo "::warning::Health check falhou"

            echo "Deploy concluido: $(date)"
          DEPLOY_SCRIPT

      - name: Cleanup SSH keys
        if: always()
        run: rm -f ~/.ssh/deploy_key
